\documentclass{hbrs-ecta-report}

\usepackage{float}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\begin{document}

\conferenceinfo{H-BRS}{2017}

\title{NeuroEvolution of Augmenting Topologies (NEAT)}
\subtitle{Steuerung eins Mario Jump \& Run Spiels}

\numberofauthors{2}
\author{
Jan Urfei\\
       \affaddr{Bonn-Rhein-Sieg University of Applied Sciences}\\
       \affaddr{Grantham-Allee 20}\\
       \affaddr{53757 Sankt Augustin, Germany}\\
       \email{jan.urfei@inf.h-brs.de}\\
\and
	Tim Lügger\\
	\affaddr{Bonn-Rhein-Sieg University of Applied Sciences}\\
	\affaddr{Grantham-Allee 20}\\
	\affaddr{53757 Sankt Augustin, Germany}\\
	\email{tim.luegger@inf.h-brs.de}\\
}
\date{today}
\maketitle
\begin{abstract}
Ziel war es eine Mario Spielfigur mit bestimmten Szenarien zu trainieren, sodass diese dann das/die Level best möglichst lösen kann.
\end{abstract}

%% ------------------------------ GENERAL NOTES ------------------------------ %%
\section{General Notes}
\label{sec:generalnotes}
\begin{itemize}
\item Do not state things you cannot confirm either by literature or experiment. This is science, not black magic.
\item Normalize your data and resulting statistical descriptors (like RMSE, $\mu$)
\item Save your experimental results to disk \textbf{before you visualize}. You \textbf{will} change your plots quite a lot after gathering the data.
\item Don't submit reports with many pages containing just a single figure. Scrolling is terrible for our health.
\item \textbf{Separate} training and test data. Don't use test data in your algorithm to learn or make decisions, they are only allowed to test the end result. If you need a separate sample set to make decisions during training or optimization, create a third (validation) set. Only your test data will really tell you how good your algorithm is. 
\end{itemize}

\subsection{Algorithm Parametrization}
Develop an actual strategy, preferably on a reduced but similar problem. You can reduce the number of samples, the targetted number of time steps your controller runs in a simulation, or any other non-destructive problem reduction method. If your algorithm has two paramers you need to adjust, it should be no problem to take 5 \textit{sensible} values per parameter and compare all combinations. For stochastic algorithms, like evolutionary approaches, make sure you \textbf{repeat your experiments} at least 5-10 times, depending on the amount of randomness. Since your algorithm makes "random" changes, just comparing single runs does not give you a good estimation on its performance. Do \textbf{not} pick your values such that they only confirm the values you \textbf{want} to use.

%% ------------------------------ STRUCTURE ------------------------------ %%
\subsection{Structure}
\label{sec:structure}
\begin{enumerate}
\item \textbf{Assignment Description}: first provide a brief description of the assignment that was handed out to you. This includes a description of the data.
\item \textbf{Approach}: describe the algorithm
\item \textbf{Experiments}: describe your experimental setup, algorithm parameters, data preprocessing first. Then include the results and a discussion thereof.
\item \textbf{Conclusion}: any conclusions about the algorithm, bugs, future work.
\end{enumerate}
%% ------------------------------ VISUALIZATION ------------------------------ %%
\subsection{Visualization}
\label{sec:visualization}

\begin{itemize}
\item Label your axes
\item Use logarithmic scale when appropriate
\item Use descriptive captions below your figures
\item Add legends if necessary
\item Make fontsizes large enough, linewidths thick enough to be readible in the final report.
\item When making comparisons, make sure the results are either in the \textbf{same} graph or graphs are plotted next to (or close to) each other.
\item \textbf{In short: make sure people can read your figures}
\end{itemize}

%% ------------------------------ REPORT STRUCTURE ------------------------------ %%
\FloatBarrier
\newpage
\newpage
\section{Assignment}
Aufgabe war es den für die HeartRate Prediction implementierten NEAT Algorithmus, der sich an dem Originalpaper \cite{Stanley2002a} orientiert, so zu verändern und anzupassen, dass er ein Problem eines Projektes löst, das sich ausgesucht werden konnte. 

In unserem Fall hieß das, eine Mario Figur durch ein Level zu bringen. Dafür muss eine neue Parametrisierung gefunden werden.

Als Trainingsdaten konnten Level generiert werden, die einen gewünschten Schwierigkeitsgrad besaßen. Die Daten, die man aus dieser Map ziehen konnte, sind die Blöcke zentriert um den Mario herum (siehe Figure \ref{fig:MarioInput}). Dabei ist jedem Blocktyp eine eigene Id zugewiesen. Aufgrund von diesen Daten soll NEAT eine Tastenkombination wählen, um den Mario zu steuern.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{img/MarioInput.jpg}
	\caption{Umgebungsblöcke des Marios für den Input}
	\label{fig:MarioInput} 
\end{figure}

\FloatBarrier
\section{Approach}

Das Herzstück von NEAT ist nahe des Papers implementiert worden. Der rudimentäre Ablauf ist auch in dem folgenden Pseudocode zu betrachten.

\begin{algorithm}[h!]
\caption{NEAT}
\label{alg:heteroneat}
\begin{algorithmic}[1]

\Function{train}{Parameters}
	\State $Parameter$: $\leftarrow$ defineSpecies($Parameter$)
	\State sort($fitness$)
	\State $Parameter$: $\leftarrow$ sharedFitness($Parameter$)
	\State $Parameter$: $\leftarrow$ defineBigSpecies($Parameter$)
	\State elitismInBigSpecies($Parameter$)
	\State $Parameter$: $\leftarrow$ defineOffspringFromSpecies($Parameter$)

	\For{species $s$ in $S$)
		\State $Parameter$: $\leftarrow$ crossover($s$,$randomSpecies$)
		\State $Parameter$: $\leftarrow$ mutate($s$) 
		
		/* mutateWeihts,add Node/Connection or Disable Connection*/
		\State $Parameter$: $\leftarrow$ appendRandomGenomes() 
		
			/* Until the population is full*/
		
	\EndFor

\EndFunction
\end{algorithmic}
\end{algorithm}

Im Gegensatz zum Original Paper habe wir noch implementiert, dass Kanten wieder Disabled werden können, damit die Topologien minimal bleiben können.

Eine besondere Herausforderung bestand darin, die Kommunikation zwischen dem Simulator (der in Java implementiert war) und unserem NEAT Algorithmus (der in Mathlab implementiert war) herzustellen. Dazu haben wir uns einer Bibliothek bedient, mit Hilfe deren man aus Java heraus Variablen in den Matlab Workspace schreiben kann. Der Simulator holt sich dann die verschiedenen Netze aus dem Workspace und berechnet an Hand des aktuellen Spielfeldes den Output bzw. den daraus resultierenden Tastendruck. Um die Kommunikation zwischen Matlab und Java möglichst gering zu halten (da diese immer sehr viel Zeit gekostet hat) ist die Berechnung der Gewichtsmatrixen, als auch der Output in Java implementiert. Hat der Simulator das Spiel soweit gebracht bis es entweder gewonnen ist, die Zeit abgelaufen ist oder der Mario gestorben ist bestimmt er eine Fitness für jede Topologie. Diese wird zurück in den Matlabworkspace geschrieben und das oben angedeutete Training ausgeführt. Danach beginnt der Prozess von neuem. In der folgenden Abbildung (Figure \ref{fig:sequenzdiagramm}) ist der Ablauf nochmals veranschaulicht.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{img/JavaMatlab.png}
	\caption{Kommunikation und Ablauf zwischen Java und Matlab}
	\label{fig:sequenzdiagramm} 
\end{figure}

Um die Trainingszeit noch schneller zu machen, haben wir ein kleineres Sichtfeld um den Mario genommen, welches lediglich 10 x 10 groß ist. Somit werden die Netze wesentlich kleiner. Des Weiteren haben wir das Sichtfeld auf den Teil rechts vom Mario beschränkt, da in unseren Level keine Rückwärtsbewegung notwendig war.

Zusätzlich um das lernen der Blöcke zu erleichtern, haben wir den Blockids einen Verlauf gegeben. So haben ähnliche Blöcke, wie z.B. welche, die  Hindernisse darstellen, ähnliche Blockids. So haben Blöcke die von großer Bedeutung für das erreichen des Ziels sind eine große Blockid (z.B. der Boden) und Blöcke die nicht so wichtig sind eine niedrige (wie z.B. Münzen).

\FloatBarrier
\section{Experiments}
Experiments are repeated 10 times. By the way, this is not enough for a description.

\subsection{Parameterization}
This would include a description of all parameter tuples and a description on how you reduced the problem to provide small and fast runs for this extensive comparison. Results would be shown in boxplots, as these provide you with the median and 25\% and 75\% percentile for every parameter tuple. This makes comparison easy, as you can plot multiple boxplots next to each other, similar as in Figure \ref{fig:4}.

\subsection{NEAT vs ESP}

\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/1.png}
\caption{Development of average mean square error, comparing NEAT and ESP}
\label{fig:1} 
\end{figure}
 
\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/2.png}
\caption{Development of min/mean/max number of nodes and edges. \textit{Legend is missing}!}
\label{fig:2} 
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/3.png}
\caption{Elite topology. Nodes are assigned their IDs. Green are input nodes, purple are output nodes.}
\label{fig:3} 
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/4.png}
\caption{Comparing MSE of NEAT and ESP}
\label{fig:4} 
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/5.png}
\caption{Approximated heart rates after 300 generations}
\label{fig:5} 
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=\linewidth]{img/6.png}
\caption{Development of species over time, averaged over 10 generations}
\label{fig:6} 
\end{figure}


\FloatBarrier
\section{Conclusion}


\bibliographystyle{abbrv}
\bibliography{HeteroNEAT} 
\end{document}
}